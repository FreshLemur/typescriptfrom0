function identityOne(val: boolean | number): boolean | number {
  return val;
}

function identityTwo(val: any): any {
  return val;
}

function identityThree<Type>(val: Type): Type {
  return val;
}

function identityFour<T>(val: T): T {
  return val;
}

Ось приклади по порядку, як працюють і для чого Generics. Нам потрібно, щоб функція прийняла якийсь тип даних і повернула той самий.

1 функція повертає нам або boolean, або number. Ми не знаємо, що точно вона поверне.

2 Функція взагалі поверне будь що.

3 Функція вже має Generics і завдяки цьому вона поверне такий тип, який їй буде переданий. Якщо це буде string, то вона поверне string і ні що інше.

4 фукнція це лише скорочення 3, сенс той самий.





Ось приклад Generics від GPT:

Generics в TypeScript - це засіб, що дозволяє створювати компоненти (функції, класи, інтерфейси), які можуть працювати з будь-яким типом даних. Вони забезпечують гнучкість коду і його перевикористання, дозволяючи нам вказувати типи даних при використанні цих компонентів.

Наприклад, ви можете створити загальну функцію для сортування масиву, яка буде працювати з будь-яким типом даних. Ось приклад:

function сортувати<T>(масив: T[]): T[] {
    return масив.slice().sort();
}

let числа: number[] = [4, 2, 5, 1];
let відсортованіЧисла = сортувати(числа);
console.log(відсортованіЧисла); // виведе: [1, 2, 4, 5]

let рядки: string[] = ["папуга", "кіт", "собака", "слон"];
let відсортованіРядки = сортувати(рядки);
console.log(відсортованіРядки); // виведе: ["кіт", "папуга", "собака", "слон"]
```

У цьому прикладі, `T` - це тип, який буде визначений під час виклику функції. Тип даних, з яким працює функція, буде використовуватися для сортування масиву, незалежно від того, чи це числа, чи рядки.